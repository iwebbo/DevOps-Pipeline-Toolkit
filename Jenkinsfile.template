// ============================================================================
// JENKINSFILE TEMPLATE COMPLET - COPY/PASTE READY
// Copier ce fichier et adapter selon tes besoins
// ============================================================================

pipeline {
    agent any
    
    parameters {
        string(name: 'APP_VERSION', defaultValue: 'latest', description: 'Version √† d√©ployer')
        choice(name: 'ACTION', choices: ['deploy', 'infrastructure-only', 'app-only', 'rollback'], description: 'Action √† effectuer')
        string(name: 'ROLLBACK_VERSION', defaultValue: '', description: 'Version pour rollback')
        booleanParam(name: 'SKIP_TESTS', defaultValue: false, description: 'Ignorer les tests')
        booleanParam(name: 'FORCE_APPROVAL', defaultValue: false, description: 'Forcer l\'approbation m√™me en DEV/STG')
    }
    
    environment {
        // Variables globales
        SLACK_WEBHOOK = credentials('slack-webhook') // Optionnel
    }
    
    stages {
        stage('üîç Auto-Detection Environment') {
            steps {
                script {
                    env.TARGET_ENV = getEnvironment()
                    env.CONFIG = getEnvConfig(env.TARGET_ENV).toString()
                    
                    echo """
üéØ INFORMATIONS DE D√âPLOIEMENT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚Ä¢ Environnement: ${env.TARGET_ENV}
‚Ä¢ Action: ${params.ACTION}
‚Ä¢ Version: ${params.APP_VERSION}
‚Ä¢ Job URL: ${env.JOB_URL}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
                    """
                }
            }
        }
        
        stage('üîí Conditional Approval') {
            when {
                anyOf {
                    environment name: 'TARGET_ENV', value: 'PRD'
                    params.FORCE_APPROVAL == true
                }
            }
            steps {
                script {
                    askApprovalIfNeeded(env.TARGET_ENV, "Confirmer ${params.ACTION} de ${params.APP_VERSION} sur ${env.TARGET_ENV} ?")
                }
            }
        }
        
        stage('üèóÔ∏è Infrastructure Deployment') {
            when {
                params.ACTION in ['deploy', 'infrastructure-only']
            }
            steps {
                script {
                    deployTerraform(env.TARGET_ENV)
                    generateAnsibleInventory(env.TARGET_ENV)
                    
                    // Sauvegarder l'inventaire pour r√©utilisation
                    stashInventory(env.TARGET_ENV)
                }
            }
        }
        
        stage('üöÄ Application Deployment') {
            when {
                params.ACTION in ['deploy', 'app-only']
            }
            steps {
                script {
                    // R√©cup√©rer l'inventaire si besoin
                    if (params.ACTION == 'app-only') {
                        try {
                            unstashInventory(env.TARGET_ENV)
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è Pas d'inventaire en stash, g√©n√©ration..."
                            generateAnsibleInventory(env.TARGET_ENV)
                        }
                    }
                    
                    deployApplication(env.TARGET_ENV, params.APP_VERSION)
                }
            }
        }
        
        stage('üîÑ Rollback') {
            when {
                params.ACTION == 'rollback'
            }
            steps {
                script {
                    if (!params.ROLLBACK_VERSION) {
                        error "‚ùå Version de rollback requise"
                    }
                    rollback(env.TARGET_ENV, params.ROLLBACK_VERSION)
                }
            }
        }
        
        stage('üè• Health Checks') {
            when {
                allOf {
                    params.ACTION in ['deploy', 'app-only', 'rollback']
                    not { params.SKIP_TESTS }
                }
            }
            steps {
                script {
                    if (!runHealthChecks(env.TARGET_ENV)) {
                        error "‚ùå Health checks √©chou√©s"
                    }
                }
            }
        }
        
        stage('üìä Post-Deploy Info') {
            when {
                params.ACTION in ['deploy', 'app-only']
            }
            steps {
                script {
                    // Afficher les URLs utiles
                    try {
                        dir('terraform') {
                            def outputs = sh(script: 'terraform output -json', returnStdout: true).trim()
                            def parsed = readJSON text: outputs
                            
                            if (parsed.load_balancer_dns?.value) {
                                echo "üåê Application URL: http://${parsed.load_balancer_dns.value}"
                                env.APP_URL = "http://${parsed.load_balancer_dns.value}"
                            }
                        }
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è Impossible de r√©cup√©rer l'URL: ${e.message}"
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Archiver les artefacts importants
                archiveArtifacts artifacts: '''
                    terraform/tfplan,
                    ansible/inventories/**/*.ini
                ''', allowEmptyArchive: true
                
                // Publier l'inventaire comme rapport
                if (fileExists("ansible/inventories/${env.TARGET_ENV}/hosts.ini")) {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: "ansible/inventories/${env.TARGET_ENV}",
                        reportFiles: 'hosts.ini',
                        reportName: 'Ansible Inventory'
                    ])
                }
            }
        }
        
        success {
            script {
                def message = "D√©ploiement ${params.APP_VERSION} r√©ussi"
                if (env.APP_URL) {
                    message += " - ${env.APP_URL}"
                }
                notifySlack(env.TARGET_ENV, "SUCCESS", message)
                
                echo "üéâ D√©ploiement termin√© avec succ√®s !"
            }
        }
        
        failure {
            script {
                notifySlack(env.TARGET_ENV, "FAILURE", "√âchec du d√©ploiement ${params.APP_VERSION}")
                
                // Proposer un rollback automatique en PRD
                if (env.TARGET_ENV == 'PRD' && params.ACTION in ['deploy', 'app-only']) {
                    echo """
üí• √âCHEC EN PRODUCTION !

üîÑ Pour effectuer un rollback:
1. Relancer cette pipeline
2. Choisir ACTION = 'rollback'  
3. Sp√©cifier ROLLBACK_VERSION

üìû Contacter l'√©quipe ops si n√©cessaire.
                    """
                }
            }
        }
        
        cleanup {
            script {
                // Nettoyage optionnel
                echo "üßπ Nettoyage termin√©"
            }
        }
    }
}

// ============================================================================
// FONCTIONS UTILITAIRES - COPIER CES FONCTIONS DANS TON JENKINSFILE
// ============================================================================

/**
 * D√©tecte l'environnement bas√© sur l'URL Jenkins
 */
def getEnvironment() {
    def jobUrl = env.JOB_URL ?: env.BUILD_URL ?: ""
    echo "üîç URL analys√©e: ${jobUrl}"
    
    if (jobUrl.contains("job/DEV/job") || jobUrl.contains("/job/DEV/")) {
        echo "‚úÖ Environnement d√©tect√©: DEV"
        return "DEV"
    }
    if (jobUrl.contains("job/STG/job") || jobUrl.contains("/job/STG/")) {
        echo "‚úÖ Environnement d√©tect√©: STG"
        return "STG"
    }
    if (jobUrl.contains("job/PRD/job") || jobUrl.contains("/job/PRD/")) {
        echo "‚úÖ Environnement d√©tect√©: PRD"
        return "PRD"
    }
    
    echo "‚ö†Ô∏è Environnement non d√©tect√©, utilisation de DEV par d√©faut"
    return "DEV"
}

/**
 * Configuration par environnement
 */
def getEnvConfig(String env) {
    def configs = [
        "DEV": [
            instanceType: "t3.micro",
            instanceCount: 1,
            needsApproval: false,
            slackChannel: "#dev-team"
        ],
        "STG": [
            instanceType: "t3.small",
            instanceCount: 2,
            needsApproval: false,
            slackChannel: "#staging-team"
        ],
        "PRD": [
            instanceType: "t3.medium",
            instanceCount: 3,
            needsApproval: true,
            slackChannel: "#prod-alerts"
        ]
    ]
    
    def config = configs[env] ?: configs["DEV"]
    echo "‚öôÔ∏è Config ${env}: ${config}"
    return config
}

/**
 * Approbation conditionnelle
 */
def askApprovalIfNeeded(String env, String message = null) {
    def config = getEnvConfig(env)
    message = message ?: "Continuer le d√©ploiement sur ${env} ?"
    
    if (config.needsApproval) {
        echo "üîí Approbation requise pour ${env}"
        timeout(time: 30, unit: 'MINUTES') {
            input message: message,
                  ok: "Approuver ${env}",
                  submitterParameter: 'APPROVER'
        }
        echo "‚úÖ Approuv√© par ${env.APPROVER ?: 'inconnu'}"
    } else {
        echo "‚è≠Ô∏è Pas d'approbation requise pour ${env}"
    }
}

/**
 * D√©ploie avec Terraform
 */
def deployTerraform(String env) {
    echo "üèóÔ∏è D√©ploiement Terraform pour ${env}"
    
    def config = getEnvConfig(env)
    
    dir('terraform') {
        sh """
            terraform init
            terraform plan -var-file="environments/${env}.tfvars" \
                          -var="instance_type=${config.instanceType}" \
                          -var="instance_count=${config.instanceCount}" \
                          -out=tfplan
            terraform apply -auto-approve tfplan
        """
    }
    echo "‚úÖ Terraform ${env} d√©ploy√©"
}

/**
 * G√©n√®re un inventaire Ansible
 */
def generateAnsibleInventory(String env) {
    echo "üìã G√©n√©ration inventaire Ansible pour ${env}"
    
    def inventoryDir = "ansible/inventories/${env}"
    sh "mkdir -p ${inventoryDir}"
    
    def outputs = [:]
    try {
        dir('terraform') {
            def tfOutput = sh(script: 'terraform output -json', returnStdout: true).trim()
            outputs = readJSON text: tfOutput
        }
    } catch (Exception e) {
        echo "‚ö†Ô∏è Impossible de r√©cup√©rer les outputs Terraform: ${e.message}"
        return false
    }
    
    def inventory = "# Inventaire ${env} - ${new Date()}\n\n"
    
    inventory += "[webservers]\n"
    if (outputs.web_servers?.value) {
        outputs.web_servers.value.each { server ->
            inventory += "${server.name} ansible_host=${server.public_ip} ansible_user=ubuntu\n"
        }
    }
    
    inventory += "\n[databases]\n"
    if (outputs.db_servers?.value) {
        outputs.db_servers.value.each { server ->
            inventory += "${server.name} ansible_host=${server.private_ip} ansible_user=ubuntu\n"
        }
    }
    
    inventory += "\n[all:vars]\n"
    inventory += "environment=${env}\n"
    
    writeFile file: "${inventoryDir}/hosts.ini", text: inventory
    echo "‚úÖ Inventaire cr√©√©: ${inventoryDir}/hosts.ini"
    sh "cat ${inventoryDir}/hosts.ini"
    return true
}

/**
 * D√©ploie l'application
 */
def deployApplication(String env, String version = "latest") {
    echo "üöÄ D√©ploiement application ${version} sur ${env}"
    
    def inventoryPath = "ansible/inventories/${env}/hosts.ini"
    
    if (!fileExists(inventoryPath)) {
        echo "üìã Inventaire manquant, g√©n√©ration..."
        if (!generateAnsibleInventory(env)) {
            error "‚ùå Impossible de g√©n√©rer l'inventaire"
        }
    }
    
    dir('ansible') {
        sh "ansible all -i ${inventoryPath} -m ping --timeout=10"
        sh """
            ansible-playbook -i ${inventoryPath} \
                            -e environment=${env} \
                            -e app_version=${version} \
                            playbooks/deploy.yml
        """
    }
    
    echo "‚úÖ Application ${version} d√©ploy√©e sur ${env}"
}

/**
 * Tests de sant√©
 */
def runHealthChecks(String env) {
    echo "üè• Tests de sant√© pour ${env}"
    
    try {
        dir('ansible') {
            sh """
                ansible webservers -i inventories/${env}/hosts.ini \
                        -m uri -a "url=http://{{ ansible_host }}/health method=GET"
            """
        }
        echo "‚úÖ Tests de sant√© OK"
        return true
    } catch (Exception e) {
        echo "‚ùå Tests de sant√© √©chou√©s: ${e.message}"
        return false
    }
}

/**
 * Notification Slack
 */
def notifySlack(String env, String status, String message) {
    if (!env.SLACK_WEBHOOK) {
        echo "üì¢ ${status}: ${message}"
        return
    }
    
    def config = getEnvConfig(env)
    def emoji = status == "SUCCESS" ? "‚úÖ" : "‚ùå"
    def payload = [
        channel: config.slackChannel,
        text: "${emoji} [${env}] ${message}",
        username: "Jenkins"
    ]
    
    try {
        sh """
            curl -X POST '${env.SLACK_WEBHOOK}' \
                 -H 'Content-Type: application/json' \
                 -d '${groovy.json.JsonOutput.toJson(payload)}'
        """
        echo "üì± Notification Slack envoy√©e"
    } catch (Exception e) {
        echo "‚ö†Ô∏è Erreur notification Slack: ${e.message}"
    }
}

/**
 * Rollback
 */
def rollback(String env, String previousVersion) {
    echo "üîÑ Rollback vers ${previousVersion} sur ${env}"
    askApprovalIfNeeded(env, "Confirmer le rollback vers ${previousVersion} ?")
    deployApplication(env, previousVersion)
    
    if (runHealthChecks(env)) {
        notifySlack(env, "SUCCESS", "Rollback vers ${previousVersion} r√©ussi")
    } else {
        notifySlack(env, "FAILURE", "Rollback vers ${previousVersion} √©chou√©")
        error "‚ùå Rollback √©chou√©"
    }
}

/**
 * Stash/Unstash inventaire
 */
def stashInventory(String env) {
    stash includes: "ansible/inventories/${env}/**", name: "inventory-${env}-${env.BUILD_NUMBER}"
    echo "üì¶ Inventaire ${env} sauvegard√©"
}

def unstashInventory(String env, String buildNumber = null) {
    buildNumber = buildNumber ?: env.BUILD_NUMBER
    unstash "inventory-${env}-${buildNumber}"
    echo "üì¶ Inventaire ${env} r√©cup√©r√©"
}